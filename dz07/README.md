Домашнее задание N07
====================

Задача 1
--------

*Какого типа команда* ***cd*** *? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.*  
  
**cd** - встроенная команда *(если верить* ***type cd*** *)*
  
Это логично: смена каталога - операция очень частая, без неё работу представить крайне сложно,  
то есть **cd** должно работать всегда, если шелл жив.  
  
Можно ли её сделать отдельной программой?  
Да, пожалуй - меняем извне переменную $PWD у шелла, и, скорее всего, оно даже будет работать.  
  
Но вот как поведёт себя конкретный шелл, если $PWD выставлен извне некорректно - вопрос для отдельного расследования.  
Ещё интересней - как поведут себя сисадмины и скрипты, если по какой-либо причине ***самостоятельной*** программы **cd**
не окажется на данной машине вовсе (а встроенной версии никогда и не было). :)  

Задача 2
--------

*Какая альтернатива без pipe команде* ***grep <some_string> <some_file> | wc -l*** *?*  
  
Вместо **grep <some_string> <some_file> | wc -l** можно применить **grep -c <some_string> <some_file>**.  
Результат тот же самый, но ни **pipe**, ни **wc -l** не нужны вовсе.  

Задача 3
--------

*Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?*  
  
Процесс с **PID** за номером **1** - это **systemd**, великий и ужасный.  

Задача 4
--------

*Как будет выглядеть команда, которая перенаправит вывод* **stderr** ***ls*** *на другую сессию терминала?*  
  
При выполнении из-под **root**'а команда будет выглядеть как-то так:  
  
**ls /fakedir 2>/dev/tty3**  

Задача 5
--------

*Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.*  
  
Например, **wc -l <README.md >wc_result**.  
  
Мы берём в качестве исходных данных **README.md**, а результат подсчёта сливаем в файл **wc_result**  

Задача 6
--------

*Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?*  
  
Можно. Как пример:  
  
**echo "from /dev/pts/1" >/dev/tty4**  
  
Отправил сообщение ***from /dev/pts/1*** с **/dev/pts/1** на **/dev/tty4**  
  
Смогу ли я наблюдать? Смогу, если переключусь на соответствующую консоль. *(Лично проверил :) )*

Задача 7
--------

*Выполните команду* ***bash 5>&1*** *. К чему она приведет? Что будет, если вы выполните* ***echo netology > /proc/$$/fd/5*** *? Почему так происходит?*  
  
1. **bash 5>&1** - всё, что пишется в башевский файл с дескриптором №5, перенаправляется в **stdout**  
  
2. **echo netology > /proc/$$/fd/5** - пишем слово ***netology*** в файл с дескриптором №5, открытый в **bash**'е  
  
3. Так как файл с дескриптором N5 уже перенаправлен в **stdout**, получим вывод слова ***netology*** на экран.  

Задача 8
--------

!TODO!

**bash 999<&2**

Задача 9
--------

*Что выведет команда* ***cat /proc/$$/environ?***  
  
Выведет массив из указателей на строки переменных пользовательского окружения.  
  
*Как еще можно получить аналогичный по содержанию вывод?*  
  
Ничего 1в1 похожего я не нашёл.  
  
**env -0** Выводит переменных много больше  
  
Если только попробовать в лоб нечто вида...  
  
**echo -e -n "SHELL="$SHELL"\x00PATH="$PATH"\x00HOME="$HOME"\x00USER="$USER"\x00LOGNAME="$LOGNAME"\x00TERM="$TERM"\x00XAUTHORITY="$XAUTHORITY"\x00DISPLAY="$DISPLAY"\x00"**
  
Тогда, по идее, вывод будет аналогичен байт-в-байт.  

Задача 10
---------

*Используя man, опишите что доступно по адресам* ***/proc/\<PID\>/cmdline*** *,* ***/proc/\<PID\>/exe***  
  
***/proc/[pid]/cmdline***
  
Данный  файл,  доступный  только  для  чтения,  содержит полную командную строку процесса, если процесс не является зомби. В  
последнем случае этот файл пуст, поэтому чтение из  него  вернёт  0  символов.  Аргументы  командной  строки  в  этом  файле  
представлены в виде набора строк, разделённых байтами null ('\0') и байтом null после последней строки.  
  
***/proc/[pid]/exe***
  
В Linux 2.2 и новее этот файл является символьной ссылкой, содержащей актуальный путь выполняемой команды. Данная символьная  
ссылка может обрабатываться обычным образом; попытка её открытия приведёт к открытию  исполняемого  файла.  Вы  даже  можете  
ввести  /proc/[pid]/exe для запуска другой копии того же  исполняемого файла, который выполняется процессом [pid]. Если путь  
был удалён, то символьная ссылка будет содержать строку  '(deleted)',  добавленную  к  оригинальному  пути.  В  многонитевом  
процессе содержимое этой символьной ссылки недоступно, если основная нить уже завершилась (обычно вызовом pthread_exit(3)).  

Задача 11
---------

*Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью* ***/proc/cpuinfo***  
  
Если верить **cat /proc/cpuinfo | grep "sse"**, то вагрантовской виртуалке доступно **sse4_2**  

Задача 12
---------

*При открытии нового окна терминала и* ***vagrant ssh*** *создается новая сессия и выделяется pty.  
Это можно подтвердить командой* ***tty*** *, которая упоминалась в лекции 3.2. Однако:*
<code>
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
</code>
*Почитайте, почему так происходит, и как изменить поведение.*

Спасает ключ **-t** после **ssh**.

Задача 13
---------

*Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую.  
Попробуйте сделать это, воспользовавшись* ***reptyr*** *. Например, так можно перенести в screen процесс,  
который вы запустили по ошибке в обычной SSH-сессии.*
  
Попробовал - получилось. Но количество подводных камней, упомянутых в мануале в разделе ***Bugs*** к **reptyr** сильно напрягает.  
И, да, эмулятор терминала, у которого "отобрали" процесс, завис намертво.
  
Действовал примерно так:  
**reptyr -T 8468**  

Задача 14
---------

***sudo echo string > /root/new_file*** *не даст выполнить перенаправление под обычным пользователем,  
так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем.  
Для решения данной проблемы можно использовать конструкцию* ***echo string | sudo tee /root/new_file*** *.  
Узнайте что делает команда* ***tee*** *и почему в отличие от* ***sudo echo*** *команда с* ***sudo tee*** *будет работать*  
  
**tee** - читает данные из **stdin** и одновременно выводит их в **stdout** и указанный файл.  
  
Главный плюс **tee** в том, что перенаправлением данных в файл она занимается лично, а не с помощью оболочки.  
Поэтому совместно с **sudo**, **tee** имеет практически неограниченные возможности писать в чужие файлы.  

