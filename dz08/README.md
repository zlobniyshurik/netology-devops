Домашнее задание N08
====================

Задача 1
--------

*Какой системный вызов делает команда* ***cd*** *? В прошлом ДЗ мы выяснили,  
что* ***cd*** *не является самостоятельной программой, это shell builtin,  
поэтому запустить* ***strace*** *непосредственно на* ***cd*** *не получится.  
Тем не менее, вы можете запустить* ***strace на /bin/bash -c 'cd /tmp'*** *.  
В этом случае вы увидите полный список системных вызовов, которые делает сам  
bash при старте. Вам нужно найти тот единственный, который относится именно к*  
***cd*** *. Обратите внимание, что* ***strace*** *выдаёт результат своей работы  
в поток* ***stderr*** *, а не в* ***stdout*** *.*
  
По идее, получим вот что:  
![Результат strace](/dz08/pic/strace1.png)
  
Строчка с **chdir** - тот самый вызов.  
  

Задача 2
--------

*Попробуйте использовать команду* ***file*** *на объекты разных типов на файловой системе. Например:*  
  
    vagrant@netology1:~$ file /dev/tty  
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64***
  
*Используя* ***strace*** *выясните, где находится база данных* ***file*** *на основании которой она делает свои догадки.*  
  
Запустив **strace file /dev/tty 2>&1**, обнаруживаем попытку обращения к нескольким подозрительным файлам:  
  
**/home/vagrant/.magic.mgc** (такого файла нет)  
**/home/vagrant/.magic** (такого файла нет)  
**/etc/magic.mgc** (такого файла нет)  
**/etc/magic**  
**/usr/share/misc/magic.mgc**  
  
**/etc/magic** оказывается хранилищем сигнатур(?) файлов,  
а в **/usr/share/misc/magic.mgc** тоже хранилище, но в бинарном формате.  
  
И если глянуть **man file**, то наши подозрения полностью подтверждаются: все пять строчек,  
перечисленных выше - возможные места хранения базы данных для утилиты **file**.  

Задача 3
--------

*Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof),  
однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет.  
Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на  
знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место  
на файловой системе).*
  
Если вопрос состоит в восстановлении контроля над удалённым файлом, то:  
  
1. Через **ps -aux** смотрим **PID** приложения  
  
2. Через **lsof -p <PID> |grep deleted** определяем номер дескриптора **nnn** удалённого файла  
  
3. Перенаправляем поток с удаленного файла на вновь созданный файл  
**/proc/\<PID\>/fd/\<nnn\> > /var/log/logfile**  
  
4. Делаем с восстановленным логом всё, что захотим (logrotate, зачистка головы, e.t.c.)  

Задача 4
--------

*Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?*

По идее, не должны - они же уже завершили свою работу (в отличие от orphaned), соответственно освободили ресурсы,  
и просто бесконечно ждут возможность вернуть свой exitcode.  
  
Единственное "но" - зомби занимают место в таблице процессов.  

Задача 5
--------

*В iovisor BCC есть утилита* ***opensnoop*** *:*  
  
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop  
    /usr/sbin/opensnoop-bpfcc  
  
*На какие файлы вы увидели вызовы группы* ***open*** *за первую секунду работы утилиты?  
Воспользуйтесь пакетом* **bpfcc-tools** *для Ubuntu 20.04.*  
  
Получилось примерно так:  
![opensnoop](/dz08/pic/opensnoop.png)
  

Задача 6
--------

*Какой системный вызов использует* ***uname -a*** *? Приведите цитату из man по этому системному вызову, где  
описывается альтернативное местоположение в* ***/proc*** *, где можно узнать версию ядра и релиз ОС.*  
  
В качестве системного вызова, если верить **strace**, используется **uname**  
  
Согласно мануалам:  
  
Часть информации из структуры **utsname** может быть получена также через */proc/sys/kernel/ {ostype, hostname, osrelease, version, domainname}*.  

Задача 7
--------

*Чем отличается последовательность команд через* ***\;*** *и через* ***\&\&*** *в* ***bash*** *? Например:*  
  
    root@netology1:~\# test -d /tmp/some_dir; echo Hi  
    Hi  
    root@netology1:~\# test -d /tmp/some_dir && echo Hi  
    root@netology1:~\#  
  
При использовании **;** команды просто выполняются последовательно.  
При использовании **\&\&** вторая команда не будет выполнена, если первая вернёт ненулевой exitcode  
(в данном случае, если каталог ***/tmp/some_dir*** не существует)  
  
*Есть ли смысл использовать в bash* ***\&\&*** *, если применить* ***set -e*** *?*  
  
Имеет - ибо всегда остаются **while**, **if**, **until** и прочие исключения, где **set -e** не работает.

Задача 8
--------

*Из каких опций состоит режим bash* ***set -euxo pipefail*** *и почему его хорошо было бы использовать в сценариях?*  
  
**-e**  
параметр **-e** указывает оболочке выйти, если команда дает ненулевой статус выхода.  
Проще говоря, оболочка завершает работу при сбое команды.  
  
**-u**  
опция **-u** обрабатывает неустановленные или неопределенные переменные как ошибки во время раскрытия параметра,  
за исключением специальных параметров, таких как подстановочные знаки (\*) или «\@».  
  
**-x**  
опция **-x** печатает аргументы команды во время выполнения  
  
**-o pipefail**  
опция **-o pipefail** позволяет сработать опции **-e** при работе с конвейерными командами.  

Почему хорош режим ***set -euxo pipefail*** - при малейшем чихе скрипт остановит исполнение, что для отладки идеально  
  
Почему плохо - опция **-x** забьёт stderr своим выводом, а скриптописателя в тёмном углу удавят коллеги.

Задача 9
--------

*Используя* ***-o stat*** *для* ***ps*** *, определите, какой наиболее часто встречающийся статус у процессов в системе.  
В* ***man ps*** *ознакомьтесь* ***(/PROCESS STATE CODES)*** *что значат дополнительные к основной заглавной буквы статуса  
процессов. Его можно не учитывать при расчете (считать* ***S*** *,* ***Ss*** *или* ***Ssl*** *равнозначными).*
  
**ps -o stat** выдал следующее:  
![ps -o stat](/dz08/pic/psstat.png)
  
Я бы это расшифровал примерно так -

