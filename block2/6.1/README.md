# Домашнее задание к занятию "6.1. Типы и структура СУБД"

## Введение

*Перед выполнением задания вы можете ознакомиться с 
[дополнительными материалами](https://github.com/netology-code/virt-homeworks/tree/master/additional/README.md).*

## Задача 1

*Архитектор ПО решил проконсультироваться у вас, какой тип БД 
лучше выбрать для хранения определенных данных.*

*Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:*

- *Электронные чеки в json виде*
- *Склады и автомобильные дороги для логистической компании*
- *Генеалогические деревья*
- *Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации*
- *Отношения клиент-покупка для интернет-магазина*

*Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.*

**Архитектор ПО решил проконсультироваться у вас, какой тип БД 
лучше выбрать для хранения определенных данных.**

Перво-наперво, объясню архитектору, что работал я только с **MySQL**, да немного с **Redis** и **ElasticSearch**, причём последние две использовались в режиме "чёрного ящика" (требовались для софта - я их поставил, запустил и больше не трогаю, пока они хоть как-то работают). Соответственно, спрашивать именно ***меня*** по БД несколько... опрометчиво.

* **Электронные чеки в json виде**  
Документоориентированные DB (MongoDB, CouchDB, e.t.c.). Главные бонусы:
  * СУБД "заточена" под данный конкретный вид данных.
  * Документы могут быть организованы (сгруппированы) в коллекции. Причем коллекции могут содержать другие коллекции.
  * API для поиска позволяет находить по запросу документы и части документов
  * В отличие от хранилищ типа ключ-значение, выборка по запросу к документному хранилищу может содержать части большого количества документов без полной загрузки этих документов в оперативную память

* **Склады и автомобильные дороги для логистической компании**  
Как выяснилось, речь идёт, в основном, о расчёте оптимальных маршрутов. Тогда безальтернативными будут графовые БД, как раз заточенные под вычисления именно такого типа.

* **Генеалогические деревья**  
Получаем дерево со строгой иерархией, где у одного потомка есть два родителя. Соответственно, нас спасут иерархические базы данных.

* **Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации**  
В данном случае прямо таки напрашивается **Redis**. Формат "ключ-значение", встроенная поддержка TTL, хранение данных в памяти (высокая скорость и так себе надёжность) - ну так это же всего лишь кэш.

* **Отношения клиент-покупка для интернет-магазина**  
Imho, тут скорее всего будет пачка связанных друг с другом таблиц, соответственно, что-нибудь типа **MySQL/PostgreSQL** будет оптимальным выбором (что конкретно - зависит от уже установленного софта и наличия специалистов).

## Задача 2

*Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно 
CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если 
(каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию):*

- *Данные записываются на все узлы с задержкой до часа (асинхронная запись)*
- *При сетевых сбоях, система может разделиться на 2 раздельных кластера*
- *Система может не прислать корректный ответ или сбросить соединение*

*А согласно PACELC-теореме, как бы вы классифицировали данные реализации?*

***Со слов преподавателя записано верно. ;)***

* **Данные записываются на все узлы с задержкой до часа (асинхронная запись)**  
*Подразумевается, что система всегда доступна, но узлы могут ответить не одинаково (данные не согласованы, но доступны и устойчивы к разделению (узлы между собой на общаются по пол часа, а, в случае проблем, могут и больше не общаться.*

  * **CAP**: **AP**-система (нет **Consistency**)

  * **PACELC**: *При сетевом разделении базы доступны и не консистентные (**PA**), а вот в  случае отсутствия разделения (например, базы синхронизируются в текущий момент) приоритеты не понятны, так что может быть как **EL** так и **EC**, хотя подсознательно ближе к тому, что система будет бороться за время ответа.*  
То есть, ответ - **PA/EL**

* **При сетевых сбоях, система может разделиться на 2 раздельных кластера**  
*На самом деле, разделение кластера на 2 узла это как раз и является **Partition Tolerance**, так как система в первую очередь остаётся живой, и, случае каких то проблем, будет отвечать всегда, и, даже если кластер развалится, то отдельные узлы будут отвечать, но, естественно, не согласованно. Отказаться от **PT** (а значит, выбрать **C** и **A**) значит полагать, что система имеет идеальную связь и никогда не теряет сообщения между своими частями - в нашем случае это не так.*

  * **CAP**: **AP**-система (ибо **Consistency** при развале кластера отсутствует)

  * **PACELC**: *При сетевом разделении базы доступны, но не консистентные (**PA**), в случае же отсутствия разделения (например, базы синхронизируются в текущий момент) приоритеты не понятны, так что может быть как **EL**, так и **EC**.*  
То есть, ответ - **PA/Ex**

* **Система может не прислать корректный ответ или сбросить соединение**  
*Если система не присылает ответ или сбрасывает соединение - значит у нее какие то проблемы. Если система живая, но часть узлов отвалилась, она решает просто игнорировать вопрошающих, чтобы, не дай бог, не дать несогласованные данные.  Некорректный ответ - это, например, код возврата c описанием проблемы кластера, ну, или при запросе БД разрывает соединение - Ну, по факту, она же отвечает. Но отрицательный результат - тоже результат. А вот **Partition Tolerance** она жертвует.*  
*Напоминаю, что отказаться от **PT** (а, значит, выбрать **C** и **A**) - значит полагать, что система имеет идеальную связь и никогда не теряет сообщения между своими частями - в нашем случае мы считаем именно так.*  
*Если бы вместо ответа было бы падение по таймауту, то тут уже явная жертва доступности, но её тут нет). Подразумевается, что ИБ все таки отвечает, но не так как бы нам хотелось(*

  * **CAP**: **AP**-система (нет **consistency**, **availability** присутствует, пусть и кривая)

  * **PACELC**: *При сетевом разделении, базы не доступны. но консистентные,  в  случае отсутствия разделения скорее всего будут готовы к задержкам, но сохранить консистентность - примеры  VoltDB/H-Store и Megastore*  
То есть, ответ **PC/EC**

## Задача 3

*Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?*

**Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?**  
По идее, не могут, ну, если только система не поддерживает два разных движка, написанных с учетом BASE и ACID-принципов соответственно.  

**BASE**: Главное - скорость ответа и доступность, приврать в данных - не возбраняется.  

**ACID**: Главное - достоверность данных, о скорости можно не мечтать, ибо сложные протоколы обработки и синхронизации данных.  

Соответственно, совместить два противоположных подхода в одной упряжке "в лоб" нереально.

## Задача 4

*Вам дали задачу написать системное решение, основой которого бы послужили:*

- *фиксация некоторых значений с временем жизни*
- *реакция на истечение таймаута*

*Вы слышали о key-value хранилище, которое имеет механизм [Pub/Sub](https://habr.com/ru/post/278237/). 
Что это за система? Какие минусы выбора данной системы?*

**Выбор БД:**
Из более-менее распространённых БД на вышеописанную роль вполне себе подойдёт **Redis**  
*(возможно, есть кандидаты и получше, но с* ***Redis*** *`ом я хотя бы в реальной жизни сталкивался, пусть и пользовался им как "чёрным ящиком" без понимания всех его глубин)*

**Минусы:**
* Все данные лежат в оперативке, на диск, если правильно помню, они тоже скидываются, но изредка. Следовательно, памяти надо много, да и с надёжностью хранения данных в случае проблем с питанием на сервере могут быть вопросы.

* И, вроде как, настройка кластера несколько нетривиальна. *(но я в такие глубины лично не залазил)*

* И, если я правильно понимаю, то нет гарантии, что подписчик гарантированно получит данные из БД (если подписчик в текущий момент чем-то занят, то, вроде как, никто ему второй раз напоминаний присылать не будет)

---

### Как cдавать задание

*Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.*

---
