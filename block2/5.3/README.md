
# Домашнее задание к занятию "5.3. Введение. Экосистема. Архитектура. Жизненный цикл Docker контейнера"

## Как сдавать задания

*Обязательными к выполнению являются задачи без указания звездочки. Их выполнение необходимо для получения зачета и диплома о профессиональной переподготовке.*

*Задачи со звездочкой (\*) являются дополнительными задачами и/или задачами повышенной сложности. Они не являются обязательными к выполнению, но помогут вам глубже понять тему.*

*Домашнее задание выполните в файле readme.md в github репозитории. В личном кабинете отправьте на проверку ссылку на .md-файл в вашем репозитории.*

*Любые вопросы по решению задач задавайте в чате учебной группы.*

---

## Задача 1

*Сценарий выполения задачи:*

- *создайте свой репозиторий на https://hub.docker.com;*
- *выберете любой образ, который содержит веб-сервер Nginx;*
- *создайте свой fork образа;*
- *реализуйте функциональность:
запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:*
```
<html>
<head>
Hey, Netology
</head>
<body>
<h1>I’m DevOps Engineer!</h1>
</body>
</html>
```
*Опубликуйте созданный форк в своем репозитории и предоставьте ответ в виде ссылки на https://hub.docker.com/username_repo.*

----

**создайте свой репозиторий на https://hub.docker.com**

Готово!  
![Мой репозиторий на hub.docker.com](https://hub.docker.com/r/zlobniyshurik/netology-devops)

----

**выберете любой образ, который содержит веб-сервер Nginx**

Возьмём **nginx:1.20.2-alpine** - стабильная ветка, маленький образ и жёстко заданная версия ПО.

----

**создайте свой fork образа**  
**реализуйте функциональность: запуск веб-сервера в фоне с индекс-страницей**  

1. Создаём каталог ***My_WWW_Dir*** для статического содержимого нашего сайта
```bash
mkdir My_WWW_Dir
```

2. Создаём в каталоге ***My_WWW_Dir*** файл **index.html** со следующим содержимым:  
```html
<html>
<head>
Hey, Netology
</head>
<body>
<h1>I'm DevOps Engineer!</h1>
</body>
</html>
```
*Не забываем поправить апостроф, а то ерунда вместо него получается...*

3. Создаём **Dockerfile** с начинкой:
```docker
FROM nginx:1.20.2-alpine

COPY My_WWW_Dir /usr/share/nginx/html

EXPOSE 80
```

4. Создаём наш докер-образ, обозвав его **first_try**  
*Получается как-то так:*  
```
[root@juggernaut dockerbuild]# docker build . -t first_try
Sending build context to Docker daemon  3.584kB
Step 1/3 : FROM nginx:1.20.2-alpine
 ---> 373f8d4d4c60
Step 2/3 : COPY My_WWW_Dir /usr/share/nginx/html
 ---> 5fba032053e2
Step 3/3 : EXPOSE 80
 ---> Running in 7cd7792a3a47
Removing intermediate container 7cd7792a3a47
 ---> 68bf79d31ced
Successfully built 68bf79d31ced
Successfully tagged first_try:latest
[root@juggernaut dockerbuild]#
```

5. Запускаем наш контейнер под более удобоваримым именем **my_nginx** и прокидываем порт с докерного 80 на хостовый 8080
```
[root@juggernaut dockerbuild]# docker run --name my_nginx -d -p 8080:80 first_try
f539d28fe5a3a219a825ac3a6b9873970a3f2e3cf8132db4ead2c13796e58293
[root@juggernaut dockerbuild]#
```

6. И видим в браузере результат

![Результат](/block2/5.3/pic/dz5_3_1.png)

7. Логинимся в докер
```
[root@juggernaut dockerbuild]# docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username: zlobniyshurik
Password: 
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
[root@juggernaut dockerbuild]#
```

8. Цепляем тэг на наш свежесозданный локальный контейнер по шаблону типа **\<hub-user\>\/\<repo-name\>\[:\<tag\>\]**
```bash
[root@juggernaut dockerbuild]# docker tag first_try:latest zlobniyshurik/netology-devops:dz5.3
```

9. Отправляем готовый образ на hub.docker.com
```
[root@juggernaut dockerbuild]# docker push zlobniyshurik/netology-devops:dz5.3
The push refers to repository [docker.io/zlobniyshurik/netology-devops]
38ad375b00f0: Pushed 
6f44c5b5d074: Mounted from library/nginx 
002fcf848e67: Mounted from library/nginx 
e419fa208fe1: Mounted from library/nginx 
112ee9c2903a: Mounted from library/nginx 
68e5252d0d33: Mounted from library/nginx 
1a058d5342cc: Mounted from library/nginx 
dz5.3: digest: sha256:b5de5a736c5ad81c71d78492811debf4842abdcf9d14dce7a2356faaa59c1a36 size: 1775
[root@juggernaut dockerbuild]#
```

10. Мой репозиторий в ![https://hub.docker.com/r/zlobniyshurik/netology-devops](https://hub.docker.com/r/zlobniyshurik/netology-devops)

## Задача 2

*Посмотрите на сценарий ниже и ответьте на вопрос:
"Подходит ли в этом сценарии использование Docker контейнеров или лучше подойдет виртуальная машина, физическая машина? Может быть возможны разные варианты?"*

*Детально опишите и обоснуйте свой выбор.*

--

*Сценарий:*

- *Высоконагруженное монолитное java веб-приложение;*
- *Nodejs веб-приложение;*
- *Мобильное приложение c версиями для Android и iOS;*
- *Шина данных на базе Apache Kafka;*
- *Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;*
- *Мониторинг-стек на базе Prometheus и Grafana;*
- *MongoDB, как основное хранилище данных для java-приложения;*
- *Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.*

**Высоконагруженное монолитное java веб-приложение**  

Тут и вариантов-то нет. Докер для монолита смысла не имеет. Виртуалка под большой нагрузкой тоже вряд ли покажет себя блестяще. Остаётся единственный выбор - физический сервер.

**Nodejs веб-приложение**  

Пожалуй, докер здесь является оптимальным вариантом. Минимум накладных расходов, простота управления и автоскейлинга.

**Мобильное приложение c версиями для Android и iOS**  

Не совсем понятно - что имеется в виду?  

Если мы говорим о запуске именно мобильных версий приложения, да под разные аппаратные платформы, то проще всего каждую версию пустить в отдельной виртуалке с эмулятором конкретной платформы.  

Если же речь идёт о серверной части мобильного приложения, то сильно зависит от того, как и на чём это самая серверная часть сделана. Возможно, получится обойтись докером, но, возможно, лучше покажет себя отдельная виртуалка или даже несколько под это вот всё.

А возможен и гибридный вариант - часть обработки в масштабируемых в зависимости от нагрузки контейнерах, а базы данных в виртуалках или даже на физических машинах.

**Шина данных на базе Apache Kafka**  

*Честно говоря, я слабо себе представляю - что это за штука и с чем её едят, но, суммируя доступные мне данные...*  
Скорее всего, если речь действительно идёт о распределённой, горизонтально масштабируемой системе (как она заявлена), то докер должен подойти.

**Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana**  

*Опыт работы с этой софтиной есть, но крайне невелик. Так что мои выводы могут не совпадать с мнением профи.*  
Напрашиваются варианты или с пачкой виртуальных машин, или же с докером, благо, на официальном сайте программы использование докера - один из предпочтительных сценариев.

**Мониторинг-стек на базе Prometheus и Grafana**

Судя по количеству докер-контейнеров с Grafana и Prometheus, это весьма подходящее решение для докеризации. Не будем спорить с интернет-сообществом.

**MongoDB, как основное хранилище данных для java-приложения**

Аксакалы и гуру крайне против применения докера в работе с базами данных, если, конечно, это не тестовая база, ценность которой равна нулю.

Тоже голосую за виртуалки или физические сервера.

**Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry.**

Докер тут точно не подойдёт - слишком сложная система с кучей процессов там внутри.

Я бы выбрал виртуалку с точки зрения упрощения администрирования и возможного аварийного восстановления. Единственное "но" - Docker Registry крайне желательно выделить на отдельный виртуальный диск.

## Задача 3

- *Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;*
- *Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера;*
- *Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```;*
- *Добавьте еще один файл в папку ```/data``` на хостовой машине;*
- *Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.*

----

**Запустите первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера**

Запускаем в первом окошке терминала centos-контейнер **интерактивно** (в фоновом он запускается и тут же завершается, ибо выполнять нечего):
```
[shurik@juggernaut dockertest]$ docker run -ti -v /home/shurik/dockertest/data:/data centos:8.4.2105
Unable to find image 'centos:8.4.2105' locally
8.4.2105: Pulling from library/centos
a1d0c7532777: Pull complete 
Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177
Status: Downloaded newer image for centos:8.4.2105
[root@97b6303a123a /]#
```

----

**Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера**

Запускаем во втором окошке терминала debian-контейнер **интерактивно** (в фоновом он запускается и тут же завершается, ибо выполнять нечего):
```
[shurik@juggernaut dockertest]$ docker run -ti -v /home/shurik/dockertest/data:/data debian:11.2
Unable to find image 'debian:11.2' locally
11.2: Pulling from library/debian
0e29546d541c: Pull complete 
Digest: sha256:2906804d2a64e8a13a434a1a127fe3f6a28bf7cf3696be4223b06276f32f1f2d
Status: Downloaded newer image for debian:11.2
root@840c0b2b2ded:/# 
```

----

**Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```**

Подключаться не будем, благо, у нас интерактивный сеанс, но файл создадим:
```bash
touch /data/file_from_centos.txt
```

----

**Добавьте еще один файл в папку ```/data``` на хостовой машине**

Создаём файл на хостовой машине:
```bash
touch /home/shurik/dockertest/data/file_from_host.txt
```

----

**Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера**

Смотрим каталог ***/data*** в debian-контейнере:
```
root@840c0b2b2ded:/# ls -la /data
total 0
drwxrwxr-x. 1 1000 1000  76 Jan 25 06:39 .
drwxr-xr-x. 1 root root 160 Jan 25 06:32 ..
-rw-r--r--. 1 root root   0 Jan 25 06:34 file_from_centos.txt
-rw-rw-r--. 1 1000 1000   0 Jan 25 06:39 file_from_host.txt
root@840c0b2b2ded:/#
```

## Задача 4 (*)

*Воспроизвести практическую часть лекции самостоятельно.*

*Соберите Docker образ с Ansible, загрузите на Docker Hub и пришлите ссылку вместе с остальными ответами к задачам.*


---

### Как cдавать задание

*Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.*

---

